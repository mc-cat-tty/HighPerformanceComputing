\chapter{Novel Issue for Shared-Memory Multi-Processors}
\section{Wanted Properties}
\begin{enumerate}
  \item Coherency
  \item Synchronization
  \item Consistency
\end{enumerate}

\section{Coherency}
For IO the memory is usually direct physical memory: no pagination no caching.

In order to avoid cache incoherency we can bus the caches.
An interconnection network connects the caches and takes care of invaliding old data in private cores' caches, by monitoring the transactions on the bus.
This specific task is performed by the cache snooper. A snoopy cache monitors the transactions on the cache bus and keeps coherent data in local caches.

How does snoopy cache coherency protocols work?

\begin{itemize}
  \item write miss: the address is invalidated in all other caches before the write is performed
  \item read miss: TODO
\end{itemize}

The simple form of cache coherency protocol is MSI - Modified Shared Invalid - protocol.
These three states are the states assigned to each cache line. Each cache line can have just one of the three states in a given moment.

Refresher on direct-mapped caches: starting from the assimption that memory is byte-addressable, meaning that is split up in 1 byte chunks, we assing a unique address to each byte.
The address has a length that depends on the size of addressable memory. In order to use an address in a direct-mapped cache we need to divide up the address in tag-index-offset bits.
Two to the power of the number of offset bits gives us the size, in bytes, of each cache line.
The index is used to index cache entries.
The tag is needed to disambiguate between indexes, since each index maps to several different memory areas.

We extend this to introduce 2 state bits that hold M/S/I.
Modified means that I hold the most recent and modified copy of the line.
Shared is the rest state.
Invalid state means I don't own the most recent copy.

TODO: copy state machine

The lazy/eager approach propagates data only if the data is accessed (read) by another processor.
This is because we want to pay the cost of propagation in case if someone else tries to read the data.

When other processors ask for the same data I hold in the modified state, I must write back data to the main memory and move myself and other processors to the shared state.

Beware that if you are the only one that keeps the copy of cache line, and no one holds the same cache line there is no need to propagate invalid state.
Also keep in mind that the modified state is ensured to be set only on one processor for each cache line. It must be unique due to the lazy model we follow.

This protocol has the drawback that generates worth of additional transactions, on top of the data movements produced by our program.

When any prcessor has cache miss or writes notify other processors via interconnection network. Only if reading many processors can have copies, if writing just one will be valid.

How to reduce coherency traffic? if a single processor reads and writes a cache line used just by himself, the data can be private. 
If the data are private we can avoid sharing coherency information between processors.

Example:
\begin{verbatim}
  int s=0;
  for (int i=0; i<N; i++) {
    s += A[i];
  }
\end{verbatim}

The loop index can be a private variable.

We therefore enhance the MSI protocol introducing a state that reflects that: \textit{E} - Exclusive but unmodified - state marks private cache lines.
The \textit{M} state now means "exclusively modified".

TODO: FSM

\subsection{Coherency Misses}
The granularity of the cache line depends on the number of offset bits. The granularity can influence the trueness of the cache miss.

True sharing miss: processors are handling same variable, locations are properly mapped to the same cache line.
False sharing miss: processors are handling different variables of locations but mapped to the same cache line.

New type of cache miss: coherency miss.

TODO: report example

A coherency false sharing miss is due to the mapping on cache lines.

How software is written impacts on these phenomena. Spacing data through the use of padding could improve performance. Padding mitigates these problems by moving data on different cache lines.

TODO: recupera diagrams and histogram

\subsection{Cache Coherent System}
The CC system must provide a set of states and its respective transition diagram. TODO: continua su additional comuncation , location of the address, invalid signals exchange